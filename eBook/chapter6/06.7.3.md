# `fmt.Println()`是如何工作的

如果你真的想掌握`syscall`的使用，通过实现`fmt.Println()`函数(可以在[https://golang.org/src/fmt/print.go](https://golang.org/src/fmt/print.go))中找到。代码如下：

```go
func Println(a ...interface{}) (n int, err error) {
 return Fprintln(os.Stdout, a...)
}
```

This means that the fmt.Println() function calls fmt.Fprintln() to do its job. The
implementation of fmt.Fprintln(), as found in the same file, is as follows:


```go
func Fprintln(w io.Writer, a ...interface{}) (n int, err error) {
 p := newPrinter()
 p.doPrintln(a)
 n, err = w.Write(p.buf)
 p.free()
 return
}
```

This means that the actual writing in fmt.Fprintln() is done by the Write() function of
the io.Writer interface. In this case, the io.Writer interface is os.Stdout, which is
defined as follows in https://golang.org/src/os/file.go:

```go
var (
 Stdin = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
 Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
 Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)
```

Now look at the implementation of NewFile(), which can be found inside https://golang.org/src/os/file_plan9.go:

```go
func NewFile(fd uintptr, name string) *File {
 fdi := int(fd)
 if fdi < 0 {
 return nil
 }
 f := &File{&file{fd: fdi, name: name}}
 runtime.SetFinalizer(f.file, (*file).close)
 return f
}
```

When you see a Go source file named file_plan9.go, you should suspect that it contains commands specific to a UNIX variant, which means that it contains code that is not portable.

What we have here is the file structure type that is embedded in the File type, which is the one that is being exported due to its name. So, start looking for functions inside https://golang.org/src/os/file_plan9.go that are applied to a File structure or to a pointer to a File structure, and that allow you to write data. As the function we are seeking is named Write() – look at the implementation of Fprintln() – we will have to search all of the source files of the os package to find it:

$ grep "func (f \*File) Write(" *.go
file.go:func (f *File) Write(b []byte) (n int, err error) {
The implementation of Write() as found in https://golang.org/src/os/file.go is as
follows:
func (f *File) Write(b []byte) (n int, err error) {
 if err := f.checkValid("write"); err != nil {
 return 0, err
 }
 n, e := f.write(b)
 if n < 0 {
 n = 0
 }
 if n != len(b) {
 err = io.ErrShortWrite
 }
 epipecheck(f, e)
 if e != nil {
 err = f.wrapErr("write", e)
 }
 return n, err
}
This means that we now have to search for the write() function. Searching for the write
string in https://golang.org/src/os/file_plan9.go reveals the following function inside
https://golang.org/src/os/file_plan9.go:
func (f *File) write(b []byte) (n int, err error) {
 if len(b) == 0 {
What You Might Not Know About Go Packages and Functions Chapter 6
[ 307 ]
 return 0, nil
 }
 return fixCount(syscall.Write(f.fd, b))
}
This tells us that a call to the fmt.Println() function is implemented using a call to
syscall.Write(). This underscores how useful and necessary the syscall package is.